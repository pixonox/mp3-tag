<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Music Tag Studio (Client‚ÄëSide)</title>
<style>
  :root{
    --bg:#0f1220; --bg2:#171a2c; --panel:#1e2240; --panel2:#24284d;
    --text:#e6e8ee; --muted:#aab0c2; --brand:#6fa8ff; --ok:#66bb6a; --warn:#ffb74d; --err:#ef5350;
    --border:rgba(255,255,255,.08);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(135deg,#151833,#0f1220 60%,#0a0d1a);color:var(--text)}
  .app{max-width:1200px;margin:24px auto;border:1px solid var(--border);border-radius:16px;overflow:hidden;background:rgba(23,26,44,.92);box-shadow:0 30px 70px rgba(0,0,0,.35)}
  .header{padding:18px 20px;background:linear-gradient(135deg,#1c2042,#252a54);border-bottom:1px solid var(--border);display:flex;align-items:center;gap:12px}
  .header h1{font-size:18px;font-weight:600;margin:0}
  .header .sub{opacity:.8;font-size:13px}
  .main{display:grid;grid-template-columns:320px 1fr;min-height:70vh}
  .sidebar{border-right:1px solid var(--border);background:linear-gradient(180deg,#1a1e3e,#151939)}
  .drop{margin:14px;border:2px dashed #4a9eff44;border-radius:12px;padding:16px;text-align:center;cursor:pointer;background:linear-gradient(135deg,#20244b,#262b55);transition:.2s}
  .drop:hover{transform:translateY(-1px);box-shadow:0 10px 20px rgba(79,156,255,.15)}
  .drop .hint{font-size:12px;color:var(--muted)}
  .filelist{padding:8px 8px 120px;overflow:auto;max-height:calc(100% - 120px)}
  .fileitem{display:flex;gap:8px;align-items:center;padding:10px;border-radius:10px;margin:6px;background:linear-gradient(135deg,#232753,#282d5d);border:1px solid var(--border);cursor:pointer}
  .fileitem.active{outline:2px solid var(--brand)}
  .filemeta{display:flex;flex-direction:column;gap:4px;min-width:0}
  .filemeta .name{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .filemeta .mini{font-size:12px;color:var(--muted)}
  .status-dot{width:10px;height:10px;border-radius:50%}
  .s-ok{background:var(--ok)} .s-warn{background:var(--warn)} .s-err{background:var(--err)} .s-idle{background:#6e7690}
  .content{padding:20px}
  .grid{display:grid;grid-template-columns:repeat(2,minmax(260px,1fr));gap:14px}
  .group{background:linear-gradient(135deg,#232753,#2a2f63);border:1px solid var(--border);border-radius:12px;padding:14px}
  .group label{display:block;font-size:12px;letter-spacing:.4px;text-transform:uppercase;color:#cfd6ea;margin-bottom:8px}
  .group input,.group textarea,.group select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #3a3f6b;background:#151833;color:var(--text);outline:none}
  .group input:focus,.group textarea:focus,.group select:focus{border-color:var(--brand);box-shadow:0 0 0 3px rgba(111,168,255,.18)}
  .art{display:flex;gap:14px;align-items:center}
  .art img{width:140px;height:140px;object-fit:cover;border-radius:10px;border:1px solid var(--border);background:#0d1022}
  .art .box{flex:1}
  .controls{display:flex;flex-wrap:wrap;gap:10px;margin-top:16px}
  .btn{padding:10px 16px;border:none;border-radius:10px;font-weight:600;cursor:pointer}
  .primary{background:linear-gradient(135deg,#4a9eff,#6fa8ff);color:#051025}
  .secondary{background:linear-gradient(135deg,#4caf50,#45a049);color:#05140a}
  .danger{background:linear-gradient(135deg,#f44336,#d32f2f);color:#2b0a0a}
  .ghost{background:#2a2f63;border:1px solid var(--border);color:#cfd6ea}
  .toolbar{display:flex;gap:10px;align-items:center;margin-bottom:14px}
  .player{display:flex;align-items:center;gap:10px;background:linear-gradient(135deg,#232753,#2a2f63);border:1px solid var(--border);border-radius:12px;padding:8px 10px}
  .tagbar{position:sticky;bottom:0;left:0;right:0;background:linear-gradient(180deg,rgba(13,16,34,.0),rgba(13,16,34,.9));padding:12px;border-top:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;gap:12px}
  .unsaved{display:none;gap:10px;align-items:center}
  .unsaved.show{display:flex}
  .progress{height:8px;border-radius:999px;background:#2a2f63;border:1px solid var(--border);overflow:hidden}
  .progress > div{height:100%;width:0;background:linear-gradient(90deg,#6fa8ff,#66bb6a)}
  .toasts{position:fixed;right:18px;bottom:18px;display:flex;flex-direction:column;gap:8px;z-index:5}
  .toast{background:#1f2449;border:1px solid var(--border);padding:10px 12px;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,.35);font-size:14px}
  .toast.ok{border-color:#2e7d32} .toast.warn{border-color:#f9a825} .toast.err{border-color:#c62828}
  .minirow{display:flex;gap:10px}
  @media (max-width:980px){ .main{grid-template-columns:1fr} .filelist{max-height:280px} .grid{grid-template-columns:1fr} }
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <h1>üéµ Music Tag Studio</h1>
    <div class="sub">Fast, client‚Äëside tag editing ‚Ä¢ MP3 write support</div>
  </div>

  <div class="main">
    <!-- Sidebar -->
    <div class="sidebar">
      <div class="drop" id="drop">
        <div style="font-size:28px">‚¨ÜÔ∏è</div>
        <div style="margin:6px 0 4px">Drop audio files or click to pick</div>
        <div class="hint">MP3 write ‚Ä¢ FLAC/M4A/OGG/WAV read</div>
        <input id="pick" type="file" multiple accept=".mp3,.flac,.m4a,.aac,.ogg,.wav,.wma" style="display:none"/>
      </div>
      <div class="filelist" id="filelist"></div>
    </div>

    <!-- Content -->
    <div class="content">
      <div class="toolbar">
        <div class="player">
          <audio id="player" controls preload="metadata" style="width:280px"></audio>
          <span id="duration" class="mini" style="font-size:12px;color:var(--muted)">--:--</span>
        </div>
        <div class="minirow">
          <input id="template" class="ghost" placeholder="Filename template e.g. {artist} - {title}" style="min-width:260px"/>
          <button class="btn ghost" id="renamePreview">Preview Name</button>
        </div>
      </div>

      <div class="grid">
        <div class="group"><label>Title</label><input id="title" placeholder="Song Title"/></div>
        <div class="group"><label>Artist</label><input id="artist" placeholder="Artist"/></div>
        <div class="group"><label>Album</label><input id="album" placeholder="Album"/></div>
        <div class="group"><label>Album Artist</label><input id="albumArtist" placeholder="Album Artist"/></div>
        <div class="group"><label>Year</label><input id="year" type="number" min="1900" max="2100" placeholder="2025"/></div>
        <div class="group"><label>Track</label><input id="track" placeholder="1/12"/></div>
        <div class="group"><label>Disc</label><input id="disc" placeholder="1/2"/></div>
        <div class="group">
          <label>Genre</label>
          <select id="genre">
            <option value="">Select Genre</option>
            <option>Electronic</option><option>Dance</option><option>House</option>
            <option>Pop</option><option>Rock</option><option>Hip-Hop</option>
            <option>R&B</option><option>Alternative</option><option>Classical</option>
            <option>Jazz</option><option>Country</option><option>Folk</option>
          </select>
        </div>
        <div class="group"><label>Composer</label><input id="composer" placeholder="Composer"/></div>
        <div class="group" style="grid-column:1/-1">
          <label>Album Artwork</label>
          <div class="art">
            <img id="cover" alt="Cover"/>
            <div class="box">
              <div class="mini" id="artinfo" style="font-size:12px;color:var(--muted)">No artwork</div>
              <div class="controls">
                <input type="file" id="artpick" accept="image/*" style="display:none"/>
                <button class="btn ghost" id="artbtn">Upload</button>
                <button class="btn ghost" id="artremove">Remove</button>
              </div>
            </div>
          </div>
        </div>
        <div class="group" style="grid-column:1/-1">
          <label>Comment</label>
          <textarea id="comment" placeholder="Notes‚Ä¶"></textarea>
        </div>
      </div>

      <div class="controls">
        <button class="btn secondary" id="reload">Reload</button>
        <button class="btn primary" id="save">Save</button>
        <button class="btn danger" id="clear">Clear Fields</button>
        <button class="btn ghost" id="applySelected">Batch Apply (selected fields ‚Üí selected files)</button>
      </div>
    </div>
  </div>

  <div class="tagbar">
    <div class="unsaved" id="unsaved"><strong>Unsaved changes</strong> ‚Ä¢ Don‚Äôt forget to save</div>
    <div style="display:flex;gap:10px;align-items:center;padding:0 12px;width:360px">
      <div class="progress" style="flex:1"><div id="bar"></div></div>
      <button class="btn ghost" id="saveAll">Save All MP3s</button>
    </div>
  </div>
</div>

<div class="toasts" id="toasts"></div>

<!-- libs -->
<script src="https://unpkg.com/music-metadata-browser/dist/music-metadata-browser.min.js"></script>
<script src="https://unpkg.com/browser-id3-writer@4.4.0/dist/browser-id3-writer.min.js"></script>

<script>
/* ---------------------------- state ---------------------------- */
const acceptExt = ['.mp3','.flac','.m4a','.aac','.ogg','.wav','.wma'];
let files = [];              // [{file, url, meta, pictureBlob, changed, canWrite, status, _mark}]
let current = -1;
let applying = false;

/* ---------------------------- helpers ---------------------------- */
const $ = id=>document.getElementById(id);
const setVal = (id,v)=>{ if(v!=null) $(id).value = v; };
const getVal = id => ( $(id).value || '' ).trim();
const parsePair = s => { if(!s) return {no:null,of:null}; const [a,b]=String(s).split('/').map(x=>x.trim()); return {no:a?+a:null, of:b?+b:null}; };
const toast = (msg,type='ok')=>{
  const el=document.createElement('div'); el.className='toast '+type; el.textContent=msg;
  $('toasts').appendChild(el); setTimeout(()=>{ el.style.opacity='0'; setTimeout(()=>el.remove(),300); }, 2600);
};
const setUnsaved = on => $('unsaved').classList.toggle('show', !!on);
const extOf = name => '.'+(name.split('.').pop()||'').toLowerCase();
const isAudioOk = name => acceptExt.includes(extOf(name));
const fmtSec = s => { if(!s && s!==0) return '--:--'; const m=Math.floor(s/60); const ss=Math.round(s%60).toString().padStart(2,'0'); return `${m}:${ss}`; };
const renderNameWithTemplate = (t, meta, fallback) => {
  if(!t) return fallback;
  return t
    .replace(/\{title\}/gi, meta.title||'')
    .replace(/\{artist\}/gi, meta.artist||'')
    .replace(/\{album\}/gi, meta.album||'')
    .replace(/\{track\}/gi, meta.trackText||'')
    .replace(/\{disc\}/gi, meta.discText||'')
    .replace(/[\\/:*?"<>|]+/g,'').trim() || fallback;
};
function updateProgress(i,total){ const pct = total? Math.round((i/total)*100):0; $('bar').style.width = pct+'%'; }

/* --------- universal native-picture extractor (APIC/covr/etc.) --------- */
function extractFirstPictureFromNative(native){
  if(!native) return null;
  // native is an object keyed by tag format, each value is an array of {id, value}
  const all = [];
  for (const arr of Object.values(native)) {
    if (Array.isArray(arr)) all.push(...arr);
  }
  // Prefer front cover-ish frames first
  const pref = ['APIC','PIC','COVER ART (FRONT)','METADATA_BLOCK_PICTURE','COVERART','COVERARTMIME','covr'];
  // Scan in order of preference
  for (const key of pref) {
    const hit = all.find(t => String(t.id || '').toUpperCase() === key.toUpperCase());
    if (hit) {
      const val = hit.value;
      // Common shapes:
      // 1) { format: 'image/jpeg', data: Uint8Array(...) }
      if (val && val.data && (val.format || val.mime)) {
        const type = val.format || val.mime || 'image/jpeg';
        try { return new Blob([val.data], { type }); } catch {}
      }
      // 2) MP4 covr often is an array (music-metadata normalizes, but be safe)
      if (Array.isArray(val) && val.length) {
        const item = val[0];
        if (item && item.data) {
          const type = item.format || item.mime || 'image/jpeg';
          try { return new Blob([item.data], { type }); } catch {}
        }
        // Sometimes it's already a Uint8Array/Buffer
        if (val[0] instanceof Uint8Array) {
          try { return new Blob([val[0]], { type:'image/jpeg' }); } catch {}
        }
      }
      // 3) Raw Buffer/Uint8Array directly
      if (val instanceof Uint8Array) {
        try { return new Blob([val], { type:'image/jpeg' }); } catch {}
      }
      // 4) String base64 (rare)
      if (typeof val === 'string' && /^data:image\//.test(val)) {
        try {
          const blob = dataURLtoBlob(val);
          if (blob) return blob;
        } catch {}
      }
    }
  }
  // Fallback: try ANY entry that looks like an image payload
  for (const t of all) {
    const v = t.value;
    if (v && v.data && (v.format || v.mime)) {
      const type = v.format || v.mime || 'image/jpeg';
      try { return new Blob([v.data], { type }); } catch {}
    }
  }
  return null;
}
function dataURLtoBlob(dataurl) {
  const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1];
  const bstr = atob(arr[1]); let n = bstr.length; const u8arr = new Uint8Array(n);
  while(n--) u8arr[n] = bstr.charCodeAt(n);
  return new Blob([u8arr], {type:mime});
}

/* -------------------------- file intake ------------------------- */
const pick = $('pick'), drop = $('drop'), list = $('filelist');
drop.addEventListener('click',()=>pick.click());
pick.addEventListener('change', e => addFiles([...e.target.files]));
drop.addEventListener('dragover', e=>{ e.preventDefault(); drop.style.transform='translateY(-1px)'; });
drop.addEventListener('dragleave', e=>{ drop.style.transform=''; });
drop.addEventListener('drop', e=>{
  e.preventDefault(); drop.style.transform='';
  if(!e.dataTransfer.files?.length) return;
  addFiles([...e.dataTransfer.files]);
});

async function addFiles(incoming){
  const added = incoming.filter(f => isAudioOk(f.name));
  if(!added.length){ toast('Drop supported audio files only','warn'); return; }
  for(const f of added){
    const url = URL.createObjectURL(f);
    files.push({file:f,url,meta:{},pictureBlob:null,changed:false,canWrite:extOf(f.name)==='.mp3',status:'idle'});
  }
  renderList();
  if(current<0) selectFile(0);
  toast(`Added ${added.length} file${added.length>1?'s':''}`);
}

/* -------------------------- list & select ----------------------- */
function renderList(){
  list.innerHTML='';
  files.forEach((it,idx)=>{
    const row = document.createElement('div');
    row.className='fileitem'+(idx===current?' active':'');
    row.addEventListener('click',()=>selectFile(idx));
    const dot = document.createElement('div'); dot.className='status-dot s-'+(it.status==='ok'?'ok':it.status==='err'?'err':it.changed?'warn':'idle');
    const meta = document.createElement('div'); meta.className='filemeta';
    const name = document.createElement('div'); name.className='name'; name.textContent = it.file.name;
    const mini = document.createElement('div'); mini.className='mini'; mini.textContent = it.canWrite?'MP3 (write)':'Read‚Äëonly';
    meta.append(name,mini); row.append(dot,meta); list.appendChild(row);
  });
}

async function selectFile(idx){
  current = idx; renderList();
  const it = files[idx];
  await loadMeta(it);
  fillForm(it);
  attachPlayer(it);
}

/* ---------------------------- reading --------------------------- */
async function loadMeta(it){
  if(it.meta && it.meta.__loaded) return; // already parsed
  try{
    // Ask for native tags too so we can scan all frames/atoms
    const parsed = await musicMetadata.parseBlob(it.file, { native: true });
    const { common, format, native } = parsed;

    const tr = common.track || {}, ds = common.disk || {};
    it.meta = {
      __loaded:true,
      title: common.title || '',
      artist: (common.artists && common.artists.join(', ')) || common.artist || '',
      album: common.album || '',
      albumArtist: common.albumartist || '',
      year: common.year || '',
      trackNo: tr.no || null, trackOf: tr.of || null,
      discNo: ds.no || null, discOf: ds.of || null,
      trackText: tr.no ? (tr.of ? `${tr.no}/${tr.of}` : `${tr.no}`) : '',
      discText: ds.no ? (ds.of ? `${ds.no}/${ds.of}` : `${ds.no}`) : '',
      genre: (common.genre && common.genre[0]) || '',
      composer: (common.composer && common.composer[0]) || '',
      comment: (common.comment && common.comment[0]) || '',
      duration: format.duration || null,
      container: format.container
    };

    // Artwork: try common first, then native scan (APIC/covr/etc.)
    if (common.picture && common.picture.length){
      const pic = common.picture[0];
      it.pictureBlob = new Blob([pic.data], { type: pic.format || 'image/jpeg' });
    } else {
      const blob = extractFirstPictureFromNative(native);
      it.pictureBlob = blob || null;
    }

    // Debug (optional): see what native tags are present
    // console.log('Native tags:', native);

  }catch(e){
    // fallback: filename parse
    const name = it.file.name.replace(/\.[^/.]+$/,'');
    const pats=[/^(.+?)\s*-\s*(.+?)\s*-\s*(.+)$/,/^(.+?)\s*-\s*(.+)$/,/^(\d+)\.\s*(.+?)\s*-\s*(.+)$/,/(.+)/];
    let m;
    if((m=name.match(pats[0]))){ it.meta = {title:m[3].trim(),artist:m[1].trim(),album:m[2].trim()}; }
    else if((m=name.match(pats[1]))){ it.meta = {title:m[2].trim(),artist:m[1].trim()}; }
    else if((m=name.match(pats[2]))){ it.meta = {title:m[3].trim(),artist:m[2].trim(),trackText:m[1]}; }
    else { it.meta = {title:name}; }
    it.pictureBlob = null;
  }
}

/* ---------------------------- UI fill --------------------------- */
function fillForm(it){
  setVal('title', it.meta.title||'');
  setVal('artist', it.meta.artist||'');
  setVal('album', it.meta.album||'');
  setVal('albumArtist', it.meta.albumArtist||'');
  setVal('year', it.meta.year||'');
  setVal('track', it.meta.trackText|| (it.meta.trackNo?String(it.meta.trackNo):''));
  setVal('disc', it.meta.discText|| (it.meta.discNo?String(it.meta.discNo):''));
  setVal('genre', it.meta.genre||'');
  setVal('composer', it.meta.composer||'');
  setVal('comment', it.meta.comment||'');
  if (it.pictureBlob){
    const u = URL.createObjectURL(it.pictureBlob);
    $('cover').src = u; $('artinfo').textContent = `${Math.round(it.pictureBlob.size/1024)} KB`;
  } else { $('cover').src=''; $('artinfo').textContent = 'No artwork'; }
  $('duration').textContent = fmtSec(it.meta.duration);
  setUnsaved(it.changed);
}

/* ---------------------------- player ---------------------------- */
function attachPlayer(it){
  $('player').src = it.url;
  $('player').onloadedmetadata = ()=> $('duration').textContent = fmtSec($('player').duration||it.meta.duration);
}

/* ---------------------- field change tracking ------------------- */
['title','artist','album','albumArtist','year','track','disc','genre','composer','comment'].forEach(id=>{
  $(id).addEventListener('input', ()=>{
    if(current<0) return;
    files[current].changed = true;
    setUnsaved(true);
    renderList();
  });
});

/* ----------------------------- artwork -------------------------- */
$('artbtn').addEventListener('click',()=> $('artpick').click());
$('artpick').addEventListener('change', async e=>{
  if(!e.target.files.length) return;
  const f = e.target.files[0];
  if(!f.type.startsWith('image/')) return toast('Pick an image','warn');
  const blob = await normalizeArtwork(f, 3000, .9);
  files[current].pictureBlob = blob;
  files[current].changed = true; setUnsaved(true); renderList();
  const u = URL.createObjectURL(blob); $('cover').src=u; $('artinfo').textContent=`${Math.round(blob.size/1024)} KB (normalized)`;
});
$('artremove').addEventListener('click',()=>{
  if(current<0) return;
  files[current].pictureBlob = null; $('cover').src=''; $('artinfo').textContent='No artwork';
  files[current].changed = true; setUnsaved(true); renderList();
});
async function normalizeArtwork(fileOrBlob, maxSide=3000, quality=.9){
  const src = URL.createObjectURL(fileOrBlob);
  const img = new Image(); img.src = src; await img.decode(); URL.revokeObjectURL(src);
  const w=img.width,h=img.height, scale=Math.min(1, maxSide/Math.max(w,h));
  const c=document.createElement('canvas'); c.width=Math.round(w*scale); c.height=Math.round(h*scale);
  const ctx=c.getContext('2d'); ctx.drawImage(img,0,0,c.width,c.height);
  return await new Promise(res=>c.toBlob(res,'image/jpeg',quality));
}

/* ---------------------------- reload/clear ---------------------- */
$('reload').addEventListener('click', async ()=>{
  if(current<0) return toast('No file selected','warn');
  files[current].meta.__loaded = false;
  await loadMeta(files[current]);
  fillForm(files[current]);
  files[current].changed = false; setUnsaved(false); renderList();
  toast('Metadata reloaded');
});
$('clear').addEventListener('click', ()=>{
  ['title','artist','album','albumArtist','year','track','disc','genre','composer','comment'].forEach(id=> setVal(id,''));
  if(current>=0){ files[current].changed = true; setUnsaved(true); renderList(); }
});

/* ---------------------------- save (single) --------------------- */
$('save').addEventListener('click', ()=> saveOne(current));
$('saveAll').addEventListener('click', saveAll);
async function saveOne(idx){
  if(idx<0) return;
  const it = files[idx];
  if(!it.canWrite) { toast('This format is read‚Äëonly (MP3 only for now).','warn'); return; }

  // collect
  const meta = {
    title:getVal('title'), artist:getVal('artist'), album:getVal('album'), albumArtist:getVal('albumArtist'),
    year:getVal('year'), track:getVal('track'), disc:getVal('disc'), genre:getVal('genre'),
    composer:getVal('composer'), comment:getVal('comment')
  };
  if (meta.year && (+meta.year<1900 || +meta.year>2100)) return toast('Year must be 1900‚Äì2100','err');

  const tr=parsePair(meta.track), ds=parsePair(meta.disc);

  try{
    const buf = await it.file.arrayBuffer();
    const writer = new ID3Writer(buf);
    writer
      .setFrame('TIT2', meta.title||'')
      .setFrame('TPE1', meta.artist ? [meta.artist] : [])
      .setFrame('TALB', meta.album||'')
      .setFrame('TPE2', meta.albumArtist||'')
      .setFrame('TDRC', meta.year||'')
      .setFrame('TRCK', tr.no ? (tr.of?`${tr.no}/${tr.of}`:`${tr.no}`) : '')
      .setFrame('TPOS', ds.no ? (ds.of?`${ds.no}/${ds.of}`:`${ds.no}`) : '')
      .setFrame('TCON', meta.genre||'')
      .setFrame('TCOM', meta.composer||'')
      .setFrame('COMM', {description:'', text: meta.comment||''});
    if (it.pictureBlob){
      const apic = new Uint8Array(await it.pictureBlob.arrayBuffer());
      writer.setFrame('APIC', {type:3, data:apic, description:'cover'});
    }
    writer.addTag();
    const out = writer.getBlob();

    // filename template
    const t = getVal('template');
    const tmpMeta = { ...it.meta, title:meta.title, artist:meta.artist, album:meta.album,
                      trackText: meta.track, discText: meta.disc };
    const base = renderNameWithTemplate(t, tmpMeta, it.file.name.replace(/\.[^/.]+$/,''));
    const name = base.endsWith('.mp3') ? base : base + '.mp3';

    download(out, name);
    it.changed = false; it.status='ok'; setUnsaved(false); renderList();
    toast('Saved ‚úîÔ∏é','ok');
  }catch(e){ console.error(e); it.status='err'; renderList(); toast('Save failed','err'); }
}
function download(blob, filename){
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=filename; document.body.appendChild(a); a.click(); a.remove();
}

/* ---------------------------- save all -------------------------- */
async function saveAll(){
  const mp3s = files.map((f,i)=>({f,i})).filter(x=>files[x.i].canWrite);
  if(!mp3s.length) return toast('No MP3s to save','warn');
  let done=0;
  for(const {i} of mp3s){
    await new Promise(res=>setTimeout(res, 10)); // keep UI responsive
    await saveOne(i);
    done++; updateProgress(done, mp3s.length);
  }
  setTimeout(()=>updateProgress(0,1), 600);
}

/* ---------------------- batch apply selected -------------------- */
$('applySelected').addEventListener('click', async ()=>{
  if(!files.length) return toast('No files loaded','warn');
  applying = !applying;
  toast(applying? 'Click files to mark for apply (click again to unmark). Click the button again to apply.' : 'Applying to marked files‚Ä¶','warn');
  if(!applying){
    // gather current editor values (only non-empty fields)
    const vals = ['title','artist','album','albumArtist','year','track','disc','genre','composer','comment']
      .reduce((acc,id)=>{ const v=getVal(id); if(v) acc[id]=v; return acc; },{});
    const pic = files[current]?.pictureBlob || null;

    const targets = files.filter(f=>f._mark);
    if(!targets.length){ toast('No files marked.','warn'); return; }

    for(const it of targets){
      Object.assign(it.meta, {
        title: vals.title ?? it.meta.title,
        artist: vals.artist ?? it.meta.artist,
        album: vals.album ?? it.meta.album,
        albumArtist: vals.albumArtist ?? it.meta.albumArtist,
        year: vals.year ?? it.meta.year,
        trackText: vals.track ?? it.meta.trackText,
        discText: vals.disc ?? it.meta.discText,
        genre: vals.genre ?? it.meta.genre,
        composer: vals.composer ?? it.meta.composer,
        comment: vals.comment ?? it.meta.comment
      });
      if (pic) it.pictureBlob = pic;
      it.changed = true;
    }
    renderList();
    toast(`Applied to ${targets.length} file${targets.length>1?'s':''}. Now ‚ÄúSave All MP3s‚Äù.`,'ok');
  }
});
list.addEventListener('click', e=>{
  if(!applying) return;
  const row = e.target.closest('.fileitem'); if(!row) return;
  const idx = [...list.children].indexOf(row);
  files[idx]._mark = !files[idx]._mark;
  row.style.outline = files[idx]._mark ? '2px dashed #ffb74d' : '';
});

/* ----------------------- rename preview ------------------------- */
$('renamePreview').addEventListener('click', ()=>{
  if(current<0) return;
  const it = files[current];
  const name = renderNameWithTemplate(getVal('template'),
    {...it.meta, trackText: getVal('track') || it.meta.trackText, discText:getVal('disc')||it.meta.discText},
    it.file.name.replace(/\.[^/.]+$/,''));
  toast('Preview: ' + (name.endsWith('.mp3')?name:name+'.mp3'), 'ok');
});

/* ----------------------- keyboard shortcuts --------------------- */
document.addEventListener('keydown', e=>{
  if(e.key==='Escape') [...document.querySelectorAll('.toast')].forEach(t=>t.remove());
  if (e.ctrlKey||e.metaKey){
    const k=e.key.toLowerCase();
    if(k==='s'){ e.preventDefault(); if(current>=0) saveOne(current); }
    if(k==='o'){ e.preventDefault(); pick.click(); }
    if(k==='b'){ e.preventDefault(); saveAll(); }
  }
});
</script>
</body>
</html>
